# 100 Day RTL Coding challenge
I write my RTL codes in Verilog on Vivado and the testbench in SystemVerilog. 

The day and corresponding RTL code is as follows:

### Week 1-2: Combinational & Sequential Logic
Day 1: Design a 4-bit AND gate.

Day 2: Implement a 4-to-1 multiplexer.

Day 3: Build a 3:8 decoder with enable.

Day 4: Create a 4-bit priority encoder.

Day 5: Design a D flip-flop with asynchronous reset.

Day 6: Build a 4-bit shift register (left/right).

Day 7: Design a 3-bit synchronous up-counter.

Day 8: Implement a 4-bit Johnson counter.

Day 9: Create a debounce circuit for a button input.

Day 10: Design a clock divider (divide-by-2, 4, 8).

### Week 3-4: Finite State Machines (FSMs)
Day 11: Moore FSM: 3-state traffic light controller.

Day 12: Mealy FSM: Edge detector (0→1 transition).

Day 13: Sequence detector for "1101".

Day 14: FSM for a vending machine (simple).

Day 15: UART TX FSM (no parity, 1 stop bit).

Day 16: UART RX FSM (with start/stop detection).

Day 17: SPI master FSM (Mode 0).

Day 18: I²C start/stop condition detector.

Day 19: PWM controller (variable duty cycle).

Day 20: Tic-Tac-Toe game controller (2-player).

### Week 5-6: Arithmetic & Data Paths
Day 21: 4-bit ripple-carry adder.

Day 22: 4-bit carry-lookahead adder.

Day 23: 4×4 multiplier (combinational).

Day 24: 8-bit ALU (ADD, SUB, AND, OR).

Day 25: Barrel shifter (8-bit, left/right).

Day 26: Fixed-point multiplier (16-bit Q8.8 format).

Day 27: GCD calculator (Euclidean algorithm).

Day 28: 32-bit population counter.

Day 29: CRC-8 generator for serial data.

Day 30: Round-robin arbiter (4 requests).

### Week 7-8: Memories & Interfaces
Day 31: Single-port RAM (16×8-bit).

Day 32: Dual-port RAM (synchronous read/write).

Day 33: FIFO (16×8-bit, with flags).

Day 34: I²C slave (respond to address 0x50).

Day 35: SPI slave (Mode 3).

Day 36: 7-segment display controller (BCD input).

Day 37: VGA sync generator (640×480 @60Hz).

Day 38: PS/2 keyboard decoder.

Day 39: I²S transmitter (stereo, 16-bit).

Day 40: Memory-mapped register bank (4 registers).

### Week 9-10: Verification & Testbenches
Day 41: Self-checking testbench for a 4-bit adder.

Day 42: Constrained-random test for FIFO.

Day 43: Assertions for a FSM (sequence detector).

Day 44: UVM test for ALU (minimal agent).

Day 45: Functional coverage for UART TX.

Day 46: Clock domain crossing (CDC) test for FIFO.

Day 47: Power-aware test (toggle coverage).

Day 48: Error injection in SPI master.

Day 49: SystemVerilog assertions for handshake protocol.

Day 50: Formal verification for a 2-bit counter.

### Week 11-14: Advanced Topics
Day 51: Pipeline stage (32-bit adder, 3-stage).

Day 52: Parametric FIR filter (3-tap).

Day 53: CORDIC rotation (sine/cosine).

Day 54: AES-128 encryption round (1 round).

Day 55: Wishbone bus interconnect (2 masters).

Day 56: AXI4-Lite slave (read/write registers).

Day 57: JTAG TAP controller (state machine).

Day 58: DDR SDRAM controller (simplified).

Day 59: PLL model (behavioral).

Day 60: Error Correcting Code (ECC) for RAM.

Day 61: Asynchronous FIFO (2 clock domains).

Day 62: Rounding modes for FP adder (IEEE 754).

Day 63: SHA-256 hash core (1 block).

Day 64: RISC-V core (RV32I, fetch/decode only).

Day 65: Cache controller (direct-mapped, 4-way).

Day 66: NoC router (2×2 mesh).

Day 67: BIST for RAM (March C- test).

Day 68: Secure boot ROM (digital signature).

Day 69: AI accelerator (matrix multiplication).

Day 70: UVM scoreboard for AES core.

### Final Sprint: Complex Systems
Day 71-80: Design a 8-bit CPU (fetch, decode, execute, memory, writeback).

Day 81-90: Build a SoC with CPU, UART, SPI, RAM, and GPIO.

Day 91-95: Verify SoC using UVM.

Day 96-100: Tapeout prep: Synthesis, timing analysis, DFT insertion.

